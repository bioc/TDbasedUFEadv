---
title: "QuickStart"
output: rmarkdown::html_vignette
bibliography: references.bib
vignette: >
  %\VignetteIndexEntry{QuickStart}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(TDbasedUFEadv)
```
# Introduction
Since TDbasedUFEadv is an extended package from TDbasedUFE, please master the contents in TDbasedUFE prior to the trial of this package. 

# Integrated Analysis of diease-drug gene expression for drug repositioning

In order to make use of TDbasedUFE for the drug riposiooning, we previously proposed[@Taguchi2017] the intergated analysis of two gene expression profiles, each of which is composed of gene expression of drug treated one and disease one. At first, we try to prepare two omics profiles, expDrug and expDisease, that represent gene expression profiles of cell lines treated by various drugs and a cell line of diseas by
``` {r}
dummy <- prepareexpDrugandDisease()
expDrug <- dummy[[1]]
expDisease <- dummy[[2]]
```
expDrug is taken from RTCGA packge and those associated with Drugs based upon [@Ding2016].  Those files are listed in drug_response.txt included in Clinical drug responses at http://lifeome.net/supp/drug_response/.
expDisease is composed of files in BRCA.rnaseq, but not included in expDrug (For more details, see source code of prepareexpDrugandDisease).
Then prepare a tensor as
```{r}
require(Biobase)
Z <- prepareTensorfromMatrix(exprs(expDrug[seq_len(200),seq_len(100)]),exprs(expDisease[seq_len(200),seq_len(100)]))
sample<- outer(colnames(expDrug)[seq_len(100)],colnames(expDisease)[seq_len(100)],function(x,y){paste(x,y)})
require(TDbasedUFE)
Z <- PrepareSummarizedExperimentTensor(sample=sample,feature=rownames(expDrug)[seq_len(200)],value=Z)
```
In the above, sample are pairs of file IDs taken from expDrug and expDisease. 
then HOSVD is applied to a tensor as
``` {r}
HOSVD <- computeHosvd(Z)
```
Here we tries to find if Cisplatin causes distinct expression between two 
classes of BRCA (in this case, there are no meaning of two classes).
``` {r}
Cond <- prepareCondDrugandDisease(expDrug)
cond <- list(NULL,Cond[,colnames="Cisplatin"][seq_len(100)],rep(1:2,each=50))
```
Then try to select singular value vectors attributed to objects.
When you try this vignettes, you can do it interactive mode as
```
input_all <- selectSingularValueVectorLarge(HOSVD,cond)
```
but in order to place this vignettes in Bioconductor that does not allow interactive input we do here as
```{r}
input_all <- selectSingularValueVectorLarge(HOSVD,cond,input_all=c(2,9))
```
Next we select which genes' expression is altered by Cisplatin.
```{r}
index <- selectFeature(HOSVD,input_all,de=0.05)
```

You might need to specify suitable value for de which is initial value of standard deviation. Finally, list the genes selected as those associated with distinct expression.
```{r}
head(tableFeatures(Z,index))
```

In the case that  there are large number of features, it is impossible to apply HOSVD to a tensor. In this case, we apply SVD instead of HOSVD to matrix generated from a tensor.
``` {r}
SVD <- computeSVD(exprs(expDrug),exprs(expDisease))
Z <- t(exprs(expDrug)) %*% exprs(expDisease)
sample<- outer(colnames(expDrug),colnames(expDisease),
               function(x,y){paste(x,y)})
Z <- PrepareSummarizedExperimentTensor(sample=sample,
            feature=rownames(expDrug),value=Z)
```
Select sigular value vectors attributed to drugs and cell lines then identify features associated e with altered expression by treatment of Cisplatin as well as ditinction etween two classes.
``` {r}
cond <- list(NULL,Cond[,colnames="Cisplatin"],rep(1:2,each=dim(HOSVD$U[[3]])[1]/2))
```
For interactive mode, one should do
````
index_all <- selectFeatureRect(SVD,cond,de=c(0.01,0.01))
```
but since packege does not allow interactive mode,  in this vignettes, we place the following.
```{r}
index_all <- selectFeatureRect(SVD,cond,de=c(0.01,0.01),input_all=3) 
```
```{r}
head(tableFeatures(Z,index_all[[1]]))
head(tableFeatures(Z,index_all[[2]]))
```
```{r}
table(index_all[[1]]$index,index_all[[2]]$index)
```

